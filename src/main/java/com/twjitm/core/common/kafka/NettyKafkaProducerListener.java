package com.twjitm.core.common.kafka;import com.twjitm.core.common.config.global.GlobalConstants;import com.twjitm.core.common.service.IService;import com.twjitm.threads.common.executor.NettyOrderThreadPoolExecutor;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.kafka.support.SendResult;import org.springframework.stereotype.Service;import org.springframework.util.concurrent.ListenableFuture;import javax.annotation.Resource;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * kafka 消息提供者 * * @author EGLS0807 - [Created on 2018-09-04 16:17] * @company http://www.g2us.com/ * @jdk java version "1.8.0_77" */@Servicepublic class NettyKafkaProducerListener implements IService {    @Resource    private KafkaTemplate<KafkaTaskType, Object> kafkaTemplate;    private NettyOrderThreadPoolExecutor nettyOrderThreadPoolExecutor;    private boolean run = true;    /**     * 消息队列     */    private BlockingQueue<AbstractKafkaTask> queue;    private void sendMessage(AbstractKafkaTask abstractKafkaTask) {        ListenableFuture<SendResult<KafkaTaskType, Object>> result =                kafkaTemplate.sendDefault(abstractKafkaTask.getTaskType(), abstractKafkaTask.getValue());    }    /**     * 将任务存放到队列中     *     * @param task     */    public void put(AbstractKafkaTask task) {        try {            queue.put(task);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    @Override    public String getId() {        return null;    }    @Override    public void startup() throws Exception {        run = true;        queue = new LinkedBlockingQueue<>();        nettyOrderThreadPoolExecutor = new NettyOrderThreadPoolExecutor(GlobalConstants.Thread.GAME_KAFKA_TASK_EXECUTOR, 4, 4);        //开启线程数量        for (int i = 0; i < 4; i++) {            nettyOrderThreadPoolExecutor.execute(new Worker());        }    }    @Override    public void shutdown() throws Exception {        run = false;    }    private class Worker implements Runnable {        @Override        public void run() {            try {                while (run) {                    sendMessage(queue.take());                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}