package com.twjitm.core.common.service.rpc.client;import com.twjitm.core.common.config.global.NettyGameServiceConfigService;import com.twjitm.core.common.netstack.entity.rpc.NettyRpcRequestMessage;import com.twjitm.core.common.netstack.entity.rpc.NettyRpcResponseMessage;import com.twjitm.core.common.service.rpc.service.NettyRpcProxyService;import com.twjitm.core.spring.SpringServiceManager;import com.twjitm.core.utils.logs.LoggerUtils;import org.apache.log4j.Logger;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.ReentrantLock;/** * @author EGLS0807 - [Created on 2018-08-20 11:38] * @company http://www.g2us.com/ * @jdk java version "1.8.0_77" */public class NettyRPCFuture implements Future<Object> {    private Logger logger = LoggerUtils.getLogger(NettyRPCFuture.class);    /**     * 同步器     */    private Sync sync;    private NettyRpcRequestMessage request;    private NettyRpcResponseMessage response;    private long startTime;    private long responseTimeThreshold = 5000;    /**     * 回调接口     */    private List<NettyAsyncRPCCallback> pendingCallbacks = new ArrayList<NettyAsyncRPCCallback>();    private ReentrantLock lock = new ReentrantLock();    public NettyRPCFuture(NettyRpcRequestMessage request) {        this.sync = new Sync();        this.request = request;        this.startTime = System.currentTimeMillis();    }    @Override    public boolean isDone() {        return sync.isDone();    }    @Override    public Object get() throws InterruptedException, ExecutionException {        sync.acquire(-1);        if (this.response != null) {            return this.response.getResult();        } else {            return null;        }    }    @Override    public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {        boolean success = sync.tryAcquireNanos(-1, unit.toNanos(timeout));        if (success) {            if (this.response != null) {                return this.response.getResult();            } else {                return null;            }        } else {            throw new RuntimeException("TIMEOUT EXCEPTION. REQUEST ID: " + this.request.getRequestId()                    + ". REQUEST CLASS NAME: " + this.request.getClassName()                    + ". REQUEST METHOD: " + this.request.getMethodName());        }    }    @Override    public boolean isCancelled() {        throw new UnsupportedOperationException();    }    @Override    public boolean cancel(boolean mayInterruptIfRunning) {        throw new UnsupportedOperationException();    }    public void done(NettyRpcResponseMessage response) {        this.response = response;        sync.release(1);        invokeCallbacks();        // Threshold        long responseTime = System.currentTimeMillis() - startTime;        if (responseTime > this.responseTimeThreshold) {            logger.warn("SERVICE RESPONSE TIME IS TOO SLOW. REQUEST ID = " + response.getRequestId() + ". RESPONSE TIME = " + responseTime + "ms");        }    }    public boolean isTimeout(){        long responseTime = System.currentTimeMillis() - startTime;        NettyGameServiceConfigService gameServerConfigService = SpringServiceManager.getSpringLoadService().getNettyGameServiceConfigService();        int timeOut = gameServerConfigService.getNettyGameServiceConfig().getRpcFutureDeleteTimeOut();        if (responseTime >= timeOut) {            return true;        }        return false;    }    private void invokeCallbacks() {        lock.lock();        try {            for (final NettyAsyncRPCCallback callback : pendingCallbacks) {                runCallback(callback);            }        } finally {            lock.unlock();        }    }    public NettyRPCFuture addCallback(NettyAsyncRPCCallback callback) {        lock.lock();        try {            if (isDone()) {                runCallback(callback);            } else {                this.pendingCallbacks.add(callback);            }        } finally {            lock.unlock();        }        return this;    }    private void runCallback(final NettyAsyncRPCCallback callback) {        final NettyRpcResponseMessage res = this.response;        NettyRpcProxyService nettyRpcProxyService = SpringServiceManager.getSpringLoadService().getNettyRpcProxyService();        nettyRpcProxyService.submit(new Runnable() {            @Override            public void run() {                if (!res.isError()) {                    callback.success(res.getResult());                } else {                    callback.fail(new RuntimeException("RESPONSE ERROR", new Throwable(res.getError())));                }            }        });    }    /**     * 实现异步回调的关键核心     *     */    static class Sync extends AbstractQueuedSynchronizer {        private static final long serialVersionUID = 1L;        private final int done = 1;        private final int pending = 0;        @Override        protected boolean tryAcquire(int acquires) {            return getState() == done ? true : false;        }        /**         * CAS操作，保证原子性         *         * @param releases         * @return         */        @Override        protected boolean tryRelease(int releases) {            if (getState() == pending) {                if (compareAndSetState(pending, done)) {                    return true;                }            }            return false;        }        public boolean isDone() {            getState();            return getState() == done;        }    }}